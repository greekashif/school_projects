import java.util.*;

/**
*	This class hosts different methods to sort
*	a collection of data stored in arrays, namely:
	<p>
*	<b>insertionSort</b>, <b>bubbleSort</b>, <b>happyHourSort</b>
 	and <b>quickSort</b>.
*
*	@author Kashif Ahmadi
*	@version 1.0
*	
*/

public class Sorting {
	
	/**
	Arranges an array in natural ordering using a Comparator method 		
	by inserting array elements appropriately in a subset of ordered
	array elements 
	This process repeates until the entire list is sorted.
	*	@param 	data		array of Census objects	
		@param comp			Comparator method
	*/
	public static void insertionSort(Census[] data, Comparator comp)
	{
		for(int i = 1; i < data.length; i++) {
			Census key = data[i];
			int pos = i;

			while(pos > 0 && (comp.compare(data[pos-1], key) > 0))
			{
				data[pos] = data[pos-1];
				pos--;
			}

			data[pos] = key;
		}
	}

	/**
	Arranges an array in natural ordering using a Comparator method 		
	by scanning the array elements left to right and placing
	the largest value in the array at the end of the array
	in the first pass, the second largest value on the second
	pass and so on.
	*	@param 	data		array of Census objects	
		@param comp			Comparator method
	*/
	public static void bubbleSort(Census[] data, Comparator comp)
	{
		int pos, scan;

		for(pos = data.length-1; pos >= 0; pos--) {
			for(scan = 0; scan <= pos - 1; scan++)
				if(comp.compare(data[scan], data[scan+1]) > 0)
					swap(data, scan, scan+1);
		}
	}
	/**
	Arranges an array in natural ordering using a Comparator method 		
	by scanning the array elements left to right and placing
	the largest value in the array at the end of the array
	in the first pass, the second largest value on the second
	pass and so on.
	*	@param 	data		array of Census objects	
		@param	comp		Comparator method
	*/
	public static void happyHourSort(Census[] data, Comparator comp)
	{
		int left = 0, right = data.length-1, scan = 0;

		while(left < right)
		{
			for(scan = left; scan <= right-1; scan++)
				if(comp.compare(data[scan], data[scan+1]) > 0)
					swap(data, scan, scan+1);

			for(scan = right-1; scan > 0; scan--)
				if(comp.compare(data[scan], data[scan-1]) < 0)
					swap(data, scan, scan-1);
			left++;
			right--;
		}
	}
	
	/**
	This method arbitrarily chooses a pivot array element
	and splits the array in order with respect to the pivot and
	this is repeated recursively until the array is sorted
	@param	data		array of Census objects
	@param  min			initial index of data array
	@param  max			last index of data array
	@param comp			Comparator method
	*/
	
	public static void quickSort(Census[] data, int min, int max, 
							 Comparator comp)
	{
		int pivot;

		if(min < max)
		{
			pivot = partition(data, min, max, comp);
			quickSort(data, min, pivot-1, comp);
			quickSort(data, pivot+1, max, comp);
		}
	}

	/**
	This method sorts each partition generated by the recursive calls
	@param	data	array of Census objects
	@param 	min		initial index of data array
	@param  max			last index of data array
	@param comp			Comparator method
	*/
	private static int partition(Census[] data, int min, int max,
								 Comparator comp)
	{
		Census first = data[min];

		int left = min;
		int right = max;

		while(left < right)
		{
			while(comp.compare(data[left], first) <= 0 && left < right)
				left++;

			while(comp.compare(data[right], first) > 0)
				right--;

			if(left < right)
				swap(data, left, right);
		}

		swap(data, min, right);

		return right;
	}
	
	/**
	Swaps the array element values
	@param data 	array of Census objects
	@param i		first index to be swapped with j
	@param j		second index to be swapped with i
	*/
	private static void swap(Census[] data, int i, int j)
	{
		Census temp = data[i];
		data[i] = data[j];
		data[j] = temp;
	}


}
